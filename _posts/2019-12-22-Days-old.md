---
title: "Days old"
categories:
  - Algorithm-Problem
tags:
  - Algorithm-Exercises
  - Practice
excerpt_separator: <!--more-->
last_modified_at: 2019-12-22T05:07:11-08:00
---
> Given your birthday and the current date, calculate your age in days. Compensate for leap days. Assume that the birthday and current date are correct dates (and no time travel). Simply put, if you were born 1 Jan 2012 and today's date is 2 Jan 2012 you are 1 day old.

<!--more-->

## Understanding Problem
----------------------
### Inputs

#### **What is the set of valid input?**

Two Dates:
- birthday date -> birthday year, month and day -> 3 integers => `(birthday_year, birthday_month, birthday_day)`
- current date -> current year, month and day -> 3 integers => `(current_year, current_month, current_day)`

> **PS**: Defensive programing -> need to check inputs
> 1. (***no time travel***) => Here, birthday date must be before current date.
> 2. Two dates need to mathch Gregorian Calendar, means the date exist. e.g. 31 Feb. 2012 isn't a right date.

#### **How are inputs represented?**

```python
(birthday_year, birthday_month, birthday_day, \
 current_year, current_month, current_day)
```

### Outputs

#### **What are the outputs?**

Days -> **`return`** **a number** giving the number of days between the birthday date and the current date -> **`return`** 1 integers -> `days_old`

#### **Define the main procedure to link inputs and outputs:**

```python
days_old = daysBetweenDates(birthday_year, birthday_month, birthday_day, \ 
                            current_year, current_month, current_day)
```
### Handy examples
Calculation by hand, list **right** inputs and **wrong** inputs(output is `undefined`):
- (2012,1,1,2012,1,1) => 0
- (2012,1,1,2012,2,28) => (31-1) + 28 = 58
- (2012,1,1,2012,3,1) => (31-1) + 29 + 1 =60 
- (2011,6,30,2012,6,30) => 366 < 2012 is the leap year>
- (2011,1,1,2013,8,8) => (365-1)+366+(365-31-30-31-30-31+8) = 950
- (2011,1,1,2014,8,8) => (365-1)+(366+365)+(365-31-30-31-30-31+8) = 1315
- (2013,8,8,2011,1,1) => `undefinded` (the birthday date is not before the current date)
- (2011,1,1,2013,8,34) => `undefinded` (August only have 31 days)
- (2011,1,1,2013,6,31) => `undefinded` (June only have 30 days)

## Solution
----------------------
### Handy solution
#### Consider **systematiclly** how a human solve the problem.
**e.g.** (2011,3,1,2014,8,8) =>  = 1256<br>
= (365-1-31-28)+(365+8-31-30-31-30-31)+(366+365) <br>
= (8-1)+(31+30+31+30+31)+(366+365+365) <br>

#### => Algorithm **Pseudocode**:
```python
daysBetweenDates(birthday_year, birthday_month, birthday_day, \ 
                            current_year, current_month, current_day)
## -------------------------------------1----------------------------------------------------- ###
days_old = current_day - birthday_day
while current_year >= birthday_year:
  days_old += (days of current_year)
  current_year -= 1
current_month -= 1
while current_month >= 1:
  days_old -= (days of current_month)
  current_month -= 1
birthday_month +=1
while 12 >= birthday_month:
  days_old -= (days of birthday_month)
  birthday_month += 1
# Can't handle:
# 1. year is the leap year
# 2. defensive check
## -------------------------------------2----------------------------------------------------- ###
days_old = current_day - birthday_day
while current_month > birthday_month:
  days_old += (days of birthday_month)
  birthday_month += 1
while current_year > birthday_year:
  days_old += (days of current_year)
  current_year -= 1
# Can't handle:
# 1. current_month < birthday_month
# 2. year is the leap year
# 3. defensive check
## -------------------------------------end----------------------------------------------------- ###
return days_old
```
> **PS**: Handy solution is always too **complex**, we need to find simpler way for computer to simplify the code.

### Simple version
#### **Assumpation**:
- every month has 30 days

#### => Algorithm **Pseudocode**:
```python
## -------------------------------Two helper functions---------------------------------------- ###
## ----------------------------------------1-------------------------------------------------- ###
# (birthday date) is before (current date) 
def isBeforeDates(year, month, day, other_year, other_month, other_day):
    if year < other_year:
        return True
    elif year == other_year:
        if month < other_month:
            return True
        elif month == other_month:
            if day < other_day:
                return True
    return False
## ----------------------------------------2-------------------------------------------------- ###
# (the next day of birthday date) 
def nextDay(year, month, day):
    assert not (day < 0 or day > 30 or month < 0 or month > 12): # defensive check

    if day < 30:
        return year, month, day+1
    if month < 12:
        return year, month+1, 1
    return year+1, 1, 1
## ---------------------------------------main------------------------------------------------ ###
def daysBetweenDates(birthday_year, birthday_month, birthday_day, \ 
                            current_year, current_month, current_day):

    days_old = 0
    while ('(birthday date) is before (current date)'):
        ('birthday date') = ('the next day of birthday date')
        days_old += 1
    return days_old

## -----------------------------------Test Function ------------------------------------------ ###
def test():
    assert isBeforeDates(2011, 2, 2, 2013, 3, 4) == True
    assert nextDay(2011, 2, 2) == (2011, 2, 3)
    assert daysBetweenDates(2011, 2, 2, 2011, 2, 3) == 1

test()
```

#### => Algorithm **Code**:
{% highlight python linenos %}
{% raw %}
# Credit goes to Websten from forums
#
# Use Dave's suggestions to finish your daysBetweenDates
# procedure. It will need to take into account leap years
# in addition to the correct number of days in each month.

def nextDay(year, month, day):
    """Simple version: assume every month has 30 days"""
    if day < 30:
        return year, month, day + 1
    else:
        if month == 12:
            return year + 1, 1, 1
        else:
            return year, month + 1, 1
        
def dateIsBefore(year1, month1, day1, year2, month2, day2):
    """Returns True if year1-month1-day1 is before year2-month2-day2. Otherwise, returns False."""
    if year1 < year2:
        return True
    if year1 == year2:
        if month1 < month2:
            return True
        if month1 == month2:
            return day1 < day2
    return False        

def daysBetweenDates(year1, month1, day1, year2, month2, day2):
    """Returns the number of days between year1/month1/day1
       and year2/month2/day2. Assumes inputs are valid dates
       in Gregorian calendar."""
    # program defensively! Add an assertion if the input is not valid!
    assert not dateIsBefore(year2, month2, day2, year1, month1, day1)
    days = 0
    while dateIsBefore(year1, month1, day1, year2, month2, day2):
        year1, month1, day1 = nextDay(year1, month1, day1)
        days += 1
    return days

def test():
    test_cases = [((2012,1,1,2012,2,28), 58), 
                  ((2012,1,1,2012,3,1), 60),
                  ((2011,6,30,2012,6,30), 366),
                  ((2011,1,1,2012,8,8), 585 ),
                  ((1900,1,1,1999,12,31), 36523)]
    
    for (args, answer) in test_cases:
        result = daysBetweenDates(*args)
        if result != answer:
            print("Test with data:", args,'=',result,' NOT' ,answer, "failed")
        else:
            print("Test case passed!", args,'=',result,' IS' ,answer,)

test()
# Test with data: (2012, 1, 1, 2012, 2, 28) = 57  NOT 58 failed
# Test case passed! (2012, 1, 1, 2012, 3, 1) = 60  IS 60
# Test with data: (2011, 6, 30, 2012, 6, 30) = 360  NOT 366 failed
# Test with data: (2011, 1, 1, 2012, 8, 8) = 577  NOT 585 failed
# Test with data: (1900, 1, 1, 1999, 12, 31) = 36000  NOT 36523 failed
{% endraw %}
{% endhighlight %}

### Develop incrementally
#### => Algorithm **Pseudocode**:
```python
## -------------------------------Four helper functions---------------------------------------- ###
## ----------------------------------------1-------------------------------------------------- ###
# (year is a leap year) 
def isLeapYear(year):
    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:
        return True
    else:
        return False
## ----------------------------------------2-------------------------------------------------- ###
# (days in the month) 
def daysInMonth(year, month):
    assert month > 0 and month <= 12
    days = [31,28,31,30,31,30,31,31,30,31,30,31]
    
    if ('year is a leap year'):
        days[1] = 29
        
    return days[month - 1]
## ----------------------------------------3-------------------------------------------------- ###
# (birthday date) is before (current date) 
def isBeforeDates(year, month, day, other_year, other_month, other_day):
    if year < other_year:
        return True
    elif year == other_year:
        if month < other_month:
            return True
        elif month == other_month:
            if day < other_day:
                return True
    return False
## ----------------------------------------4-------------------------------------------------- ###
# (the next day of birthday date) 
def nextDay(year, month, day)
    assert not (day < 0 or day > 30 or month < 0 or month > 12): # defensive check

    if day < ('days in the month'):
        return year, month, day+1
    if month < 12:
        return year, month+1, 1
    return year+1, 1, 1
## ---------------------------------------main------------------------------------------------ ###
def daysBetweenDates(birthday_year, birthday_month, birthday_day, \ 
                            current_year, current_month, current_day):

    days_old = 0
    while ('(birthday date) is before (current date)'):
        ('birthday date') = ('the next day of birthday date')
        days_old += 1
    return days_old

## -----------------------------------Test Function ------------------------------------------ ###
def test():
    assert isBeforeDates(2011, 2, 2, 2013, 3, 4) == True
    assert isLeapYear(2012) == True
    assert daysInMonth(2012, 2) == 29
    assert nextDay(2011, 2, 2) == (2011, 2, 3)
    assert daysBetweenDates(2011, 2, 2, 2011, 2, 3) == 1

test()
```
#### => Algorithm **Code**:
{% highlight python linenos %}
{% raw %}
# Credit goes to Websten from forums
#
# Use Dave's suggestions to finish your daysBetweenDates
# procedure. It will need to take into account leap years
# in addition to the correct number of days in each month.

def isLeapYear(year):
    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:
        return True
    else:
        return False

def daysInMonth(year, month):
    assert month > 0 and month <= 12
    days = [31,28,31,30,31,30,31,31,30,31,30,31]
    
    if isLeapYear(year):
        days[1] = 29
        
    return days[month - 1]
    
def nextDay(year, month, day):
    """Simple version: assume every month has 30 days"""
    days = daysInMonth(year, month)
    if day < days:
        return year, month, day + 1
    else:
        if month == 12:
            return year + 1, 1, 1
        else:
            return year, month + 1, 1
        
def dateIsBefore(year1, month1, day1, year2, month2, day2):
    """Returns True if year1-month1-day1 is before year2-month2-day2. Otherwise, returns False."""
    if year1 < year2:
        return True
    if year1 == year2:
        if month1 < month2:
            return True
        if month1 == month2:
            return day1 < day2
    return False        

def daysBetweenDates(year1, month1, day1, year2, month2, day2):
    """Returns the number of days between year1/month1/day1
       and year2/month2/day2. Assumes inputs are valid dates
       in Gregorian calendar."""
    # program defensively! Add an assertion if the input is not valid!
    assert not dateIsBefore(year2, month2, day2, year1, month1, day1)
    days = 0
    while dateIsBefore(year1, month1, day1, year2, month2, day2):
        year1, month1, day1 = nextDay(year1, month1, day1)
        days += 1
    return days

def test():
    test_cases = [((2012,1,1,2012,2,28), 58), 
                  ((2012,1,1,2012,3,1), 60),
                  ((2011,6,30,2012,6,30), 366),
                  ((2011,1,1,2012,8,8), 585 ),
                  ((1900,1,1,1999,12,31), 36523)]
    
    for (args, answer) in test_cases:
        result = daysBetweenDates(*args)
        if result != answer:
            print("Test with data:", args,'=',result,' NOT' ,answer, "failed")
        else:
            print("Test case passed!", args,'=',result,' IS' ,answer,)

test()
# Test case passed! (2012, 1, 1, 2012, 2, 28) = 58  IS 58
# Test case passed! (2012, 1, 1, 2012, 3, 1) = 60  IS 60
# Test case passed! (2011, 6, 30, 2012, 6, 30) = 366  IS 366
# Test case passed! (2011, 1, 1, 2012, 8, 8) = 585  IS 585
# Test case passed! (1900, 1, 1, 1999, 12, 31) = 36523  IS 36523
{% endraw %}
{% endhighlight %}
### Optimazation


## Algorithm Analysis
----------------------


